<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>함수</h1>

    <!-- 선언적 함수 -->
    <script>
      // function 함수명(매개변수) {return 결과값;}
      // 매개변수와 결과값 생략 가능(없어도 함수 만들 수 있음)
      // 참고. 함수명 camelCase(낙타표기법)
      function sample() {
        console.log("ㅋㅋㅋㅋㅋㅋ");
      }
      sample();

      function plus(a, b) {
        return a + b;
      }
      const result = plus(10, 20); //답은 30이 맞지만 console에는 보이지 않음
      console.log(plus(10, 20)); //console에 30 출력
      console.log(result); //위와 같음 : 30

      const sample1 = sample();
      console.log(sample1); //undefined -> return 값이 없어서!

      // 두 수의 값을 더하는 계산
      console.log(plus(3, 7));
      console.log(plus(4, 9));
      console.log(plus(5, 6));
    </script>
    <!-- 변수의 유효범위(Scope) -->
    <!-- 
        const(변수)를 바깥에서 쓴건 함수 안에서 쓸 수 있지만 안에서 쓴 건 함수 밖에서 사용 불가능
     -->
    <script>
      const num1 = 100;
      function sample2() {
        const num1 = 200;
        console.log(`sample2 내부 : ${num1}`); //200 : 바깥 num1이 100이고 안에 200일 때 함수 안의 것이 우선순위가 됨

        function sample3() {
          const num2 = 30000;
        }
      }

      console.log(`sample2 외부 : ${num1}`); //100 : 외부에서는 함수 안에 있는 num1=200;을 인식하지 않음
      console.log(`num2 : ${num2}`); //오류 : 함수 내부에서의 변수는 외부에서 출력x
      sample2(); //호출이 이 부분이라 console 확인 시 외부가 내부보다 먼저 찍혀있음
    </script>

    <!-- 익명 함수 -->
    <!-- 
        funtion 뒤 함수명이 생략됨
     -->
    <script>
      // const 변수 = function 함수명(파라미터) {return 결과값;}
      const minus = function (a, b) {
        return a - b;
      };
      console.log(minus(70, 30)); //40
    </script>

    <!-- 화살표 함수 -->
    <!-- 
        function을 없애는 대신 파라미터와 결과값 사이에 화살표가 들어감
     -->
    <script>
      const minus2 = (a, b) => {
        return a - b;
      };
      console.log(minus2(100, 30)); //70
      // 정렬에서 변수.sort((a,b)=>a-b);는 함수 사용한 것
    </script>

    <!-- 배열.함수(콜백함수) -->
    <!-- 함수 뒤 파라미터 자리에 콜백함수를 넣음 -->
    <!-- 배열 문제에 활용 가능 -->
    <script>
      const arr = [1, 2, 3, 4, 5, 6, 7];
      // forEach : 값을 하나씩 가져올 수 있다.
      // 배열.forEach((값, 인덱스, 배열)=>{});
      arr.forEach((data) => {
        console.log(data);
      });
      arr.forEach((data, index /*array*/) => {
        //값, 인덱스, 배열 순으로 찍힘
        // 생략도 가능
        console.log(data);
        console.log(index);
        // console.log(array);
      });

      //map : 리턴한 값들을 기반으로 새로운 배열을 만든다.
      // 배열.map((값, 인덱스, 배열)=>{});
      const arr2 = arr.map(function (data) {
        return data * 2;
      });
      console.log(arr2); //[2,4,6,8,10,12,14]

      // filter : 리턴한 값들이 true인 것들만 모아서 새로운 배열을 만든다.
      // 배열.filter((값, 인덱스, 배열)=>{});
      const arr3 = arr.filter((data) => {
        return data % 2 === 0;
      });
      console.log(arr3); //[2, 4, 6]

      // reduce : 하나의 결과값을 반환한다.
      // 배열.reduce((누적된값, 값, 인덱스, 배열)=> {}, 초기값);
      const result2 = arr.reduce((accumulator, data) => {
        return accumulator + data;
        // accumulator = accumulator + data
      });
      console.log(result2); //28 : 1~7까지 다 더한 합
      //   accumulator : 누적되는 값
    </script>
  </body>
</html>
